<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Storix Energy Saving Simulator</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js for visualization -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Load Simulation Data -->
    <script>
    const SIM_DATA = {
  "hours": [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23],
  "baseline_household_kw": [
    0.5179, 0.6539, 0.3404, 0.2694, 0.3469, 0.268, 0.8976, 2.3629,
    2.9729, 1.9952, 1.4271, 3.9708, 1.4308, 0.5538, 1.6954, 1.2912,
    0.6835, 1.8244, 3.3644, 3.1902, 2.9339, 1.6947, 0.8519, 0.3761
  ],
  "scale_transmission": 2000000,
  "scale_distribution": 5000,
  "line_params": {
    "transmission": {
      "voltage_kv": 750,
      "name": "LGJ-300/25 ACSR",
      "resistance_dc_20_per_km_single": 0.03,
      "num_bundle": 2,
      "diameter_mm": 23.94,
      "emissivity": 0.5,
      "absorptivity": 0.5
    },
    "distribution": {
      "voltage_kv": 10,
      "name": "JKLYJ-10/240",
      "resistance_dc_20_per_km": 0.118,
      "diameter_mm": 22.0,
      "emissivity": 0.9,
      "absorptivity": 0.9
    }
  }
};
    </script>
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #000000; color: #cbd5e1; }
        .card { background: #111827; border: 1px solid #1f2937; border-radius: 12px; padding: 20px; margin-bottom: 20px; }
        .metric-value { font-size: 1.5rem; font-weight: 700; color: #f1f5f9; }
        .metric-label { font-size: 0.875rem; color: #94a3b8; }
        /* Standardized Colors */
        .highlight-green { color: #10b981; } /* Emerald 500 */
        .highlight-red { color: #ef4444; } /* Red 500 */
        
        /* Form inputs dark mode override */
        input[type="text"], input[type="number"] {
            background-color: #1f2937;
            border-color: #374151;
            color: #f3f4f6;
        }
        input[type="range"] {
            background-color: #374151;
        }
    </style>
</head>
<body class="p-6 max-w-7xl mx-auto">

    <!-- Navigation -->
    <nav class="flex justify-between items-center mb-8 py-2 border-b border-slate-800 pb-6">
        <div class="flex items-center gap-2">
            <div class="text-3xl font-black text-white tracking-tighter">STORIX</div>
        </div>
        <div class="space-x-8 text-sm font-medium text-slate-400">
            <a href="index.html" class="hover:text-white transition-colors">Home</a>
            <a href="about.html" class="hover:text-white transition-colors">About</a>
            <a href="product-overview.html" class="hover:text-white transition-colors">Product</a>
            <a href="purchase.html" class="text-white border-b-2 border-[#4E80EE] pb-1">Product Lineup</a>
        </div>
    </nav>

    <!-- Header -->
    <div class="mb-8 text-center">
        <h1 class="text-3xl font-bold text-white">Storix Isothermal Simulator</h1>
        <p class="text-slate-400 mt-2">Experimental Mode: Regulating Load to Maintain Constant Conductor Temperature</p>
    </div>

    <!-- Controls -->
    <div class="card">
        <h3 class="text-lg font-semibold text-white mb-4">üìç Location & Weather Data</h3>
        
        <div class="grid grid-cols-1 md:grid-cols-4 gap-4 items-start">
            <!-- Col 1: Search (Span 1) & Forecast (Span 1) -->
            <div class="md:col-span-2 space-y-4">
                <div>
                    <label class="block text-sm font-medium text-slate-400">Search City</label>
                    <div class="flex mt-1">
                        <input type="text" id="cityInput" placeholder="e.g. London, Tokyo, New York" class="flex-1 rounded-l-md border border-slate-700 p-2 focus:ring-[#4E80EE] focus:border-[#4E80EE]">
                        <button onclick="fetchWeatherData()" class="bg-[#4E80EE] text-white px-4 py-2 rounded-r-md hover:bg-[#3A60B2] font-bold transition-colors">
                            Fetch Weather
                        </button>
                    </div>
                    <p id="locationStatus" class="text-sm text-slate-500 mt-1">Enter a city to load real-time forecast data.</p>
                </div>
                
                <div class="bg-slate-900 p-3 rounded border border-slate-700 text-sm">
                    <p class="font-semibold text-slate-300">Current Forecast Data:</p>
                    <div id="weatherSummary" class="mt-1 text-slate-400">
                        Using default constant values.
                    </div>
                </div>
            </div>

            <!-- Col 2: Grid Scale & Daily Usage (Stacked) -->
            <div>
                <div class="mb-4">
                    <label class="block text-sm font-medium text-slate-400">Grid Scale (Households)</label>
                    <div class="flex items-center gap-2">
                        <input type="range" id="gridScaleInput" min="10000" max="20000000" step="10000" value="2000000" class="mt-1 flex-1 h-2 rounded-lg appearance-none cursor-pointer accent-[#4E80EE]" oninput="document.getElementById('gridScaleVal').innerText = (this.value/1000000).toFixed(2) + ' M'; updateSimulation()">
                        <span id="gridScaleVal" class="text-sm font-bold text-slate-200 w-16">2.00 M</span>
                    </div>
                    <p class="text-xs text-slate-500 mt-1">Range: 10k - 20M Households</p>
                </div>

                <div>
                    <label class="block text-sm font-medium text-slate-400">Daily Usage (kWh/hh)</label>
                    <div class="flex items-center gap-2">
                        <input type="number" id="dailyUsageInput" step="0.1" value="30.5" class="mt-1 w-24 rounded-md border border-slate-700 p-1 text-right focus:border-[#4E80EE] focus:ring-[#4E80EE]" onchange="updateSimulation()">
                        <span class="text-sm text-slate-500">kWh</span>
                    </div>
                    <p class="text-xs text-slate-500 mt-1">Scales baseline profile.</p>
                </div>
            </div>

            <!-- Col 3: Battery Capacity -->
            <div>
                <label class="block text-sm font-medium text-slate-400">Battery Capacity (kWh)</label>
                <div class="flex items-center gap-2">
                    <input type="range" id="batteryCapInput" min="5" max="100" step="0.5" value="15" class="mt-1 flex-1 h-2 rounded-lg appearance-none cursor-pointer accent-[#4E80EE]" oninput="document.getElementById('batteryCapVal').innerText = this.value + ' kWh'; updateSimulation()">
                    <span id="batteryCapVal" class="text-sm font-bold text-slate-200 w-16">15 kWh</span>
                </div>
                <p class="text-xs text-slate-500 mt-1">Per household. 95% efficiency.</p>
                <div class="mt-2 flex flex-col gap-2">
                    <div class="flex items-center gap-2">
                        <button onclick="findOptimalBatteryCapacity()" class="bg-[#10b981] text-white px-3 py-2 rounded-md hover:bg-emerald-600 font-semibold text-xs transition-colors">Max Net Savings</button>
                        <span id="optimalCapVal" class="text-xs text-slate-400"></span>
                    </div>
                    <div class="flex items-center gap-2">
                        <button onclick="findOptimalBatteryEfficiency()" class="bg-[#4E80EE] text-white px-3 py-2 rounded-md hover:bg-[#3A60B2] font-semibold text-xs transition-colors">Max Savings/kWh</button>
                        <span id="optimalEffVal" class="text-xs text-slate-400"></span>
                    </div>
                </div>
            </div>

            <!-- Re-Run Button -->
            <div class="md:col-span-4 mt-2">
                 <button onclick="updateSimulation()" class="w-full bg-slate-800 text-slate-200 border border-slate-700 p-2 rounded-md hover:bg-slate-700 font-semibold transition-colors">
                    Re-Run Simulation
                </button>
            </div>
        </div>
    </div>

    <!-- System Visualization -->
    <div class="card overflow-hidden">
        <h3 class="text-lg font-semibold text-white mb-8">System Visualization & Savings Breakdown</h3>
        
        <div class="relative flex items-center justify-between min-w-[600px]">
            <!-- Connecting Line Background -->
            <div class="absolute top-1/2 left-0 w-full h-1 bg-slate-800 -z-10 -translate-y-1/2"></div>

            <!-- Node 1: Power Plant -->
            <div class="flex flex-col items-center bg-slate-900 px-2 z-10">
                <div class="w-16 h-16 bg-slate-800 rounded-full flex items-center justify-center text-3xl shadow-sm border border-slate-700 mb-2">
                    üè≠
                </div>
                <div class="font-bold text-slate-200">Power Plant</div>
                <div class="text-xs text-slate-500">Source</div>
            </div>

            <!-- Link 1: Transmission -->
            <div class="flex-1 flex flex-col items-center px-4">
                <div class="bg-[#4E80EE]/20 border border-[#4E80EE]/50 rounded px-3 py-1 mb-2 text-center shadow-sm w-full max-w-[200px]">
                    <div class="text-xs font-semibold text-[#4E80EE] uppercase tracking-wider">Transmission Line</div>
                    <div class="text-lg font-bold text-[#4E80EE]" id="vizTransSavings">0 kWh</div>
                    <div class="text-xs text-slate-400">Saved Today</div>
                </div>
                
                <!-- Controls for Trans Line -->
                <div class="w-full max-w-[200px] bg-slate-900 border border-slate-700 rounded p-2 mb-1">
                     <div class="flex justify-between text-xs text-slate-400 mb-1">
                        <span>Length</span>
                        <span id="vizTransLen">1000 km</span>
                    </div>
                    <input type="range" id="transLenSlider" min="0" max="5000" step="100" value="1000" class="w-full h-1 rounded-lg appearance-none cursor-pointer accent-[#4E80EE]" oninput="updateSimulation()">
                </div>

                <div class="text-xs text-slate-500 bg-slate-900 px-2">
                    <span id="vizTransVolt">1000 kV</span>
                </div>
                <div class="text-xs text-slate-500 mt-1 bg-slate-900 px-2">
                    <span id="vizTransWeather">Temp: --</span>
                </div>
            </div>

            <!-- Node 2: Substation -->
            <div class="flex flex-col items-center bg-slate-900 px-2 z-10">
                <div class="w-16 h-16 bg-slate-800 rounded-full flex items-center justify-center text-3xl shadow-sm border border-slate-700 mb-2">
                    ‚ö°
                </div>
                <div class="font-bold text-slate-200">Substation</div>
                <div class="text-xs text-slate-500">Step Down</div>
            </div>

            <!-- Link 2: Distribution -->
            <div class="flex-1 flex flex-col items-center px-4">
                <div class="bg-[#4E80EE]/20 border border-[#4E80EE]/50 rounded px-3 py-1 mb-2 text-center shadow-sm w-full max-w-[200px]">
                    <div class="text-xs font-semibold text-[#4E80EE] uppercase tracking-wider">Distribution Line</div>
                    <div class="text-lg font-bold text-[#4E80EE]" id="vizDistSavings">0 kWh</div>
                    <div class="text-xs text-slate-400">Saved Today</div>
                </div>

                <!-- Controls for Dist Line -->
                <div class="w-full max-w-[200px] bg-slate-900 border border-slate-700 rounded p-2 mb-1">
                     <div class="flex justify-between text-xs text-slate-400 mb-1">
                        <span>Length</span>
                        <span id="vizDistLen">20 km</span>
                    </div>
                    <input type="range" id="distLenSlider" min="1" max="10000" step="1" value="20" class="w-full h-1 rounded-lg appearance-none cursor-pointer accent-[#4E80EE]" oninput="updateSimulation()">
                </div>

                <div class="text-xs text-slate-500 bg-slate-900 px-2">
                    <span id="vizDistVolt">35 kV</span>
                </div>
                <div class="text-xs text-slate-500 mt-1 bg-slate-900 px-2">
                    <span id="vizDistWeather">Temp: --</span>
                </div>
            </div>

            <!-- Node 3: Households -->
            <div class="flex flex-col items-center bg-slate-900 px-2 z-10">
                <div class="w-16 h-16 bg-slate-800 rounded-full flex items-center justify-center text-3xl shadow-sm border border-slate-700 mb-2">
                    üè†
                </div>
                <div class="font-bold text-slate-200">Households</div>
                <div class="text-xs text-slate-500" id="vizHouseCount">2M Users</div>
            </div>
        </div>
    </div>

    <!-- Summary Metrics (Moved Up) -->
    <div class="card bg-slate-900 border-[#4E80EE]/50 border mb-6">
        <div class="mb-4 border-b border-[#4E80EE]/50 pb-2">
            <h2 class="text-xl font-bold text-slate-200">Impact Summary</h2>
            <p class="text-slate-400 mt-1">
                Data scaled to represent a regional grid serving 
                <strong class="text-[#4E80EE]" id="householdCountDisplay">2,000,000</strong> households.
            </p>
        </div>
        <div class="grid grid-cols-1 md:grid-cols-4 gap-6">
            <div>
                <p class="metric-label">Peak Current Reduction</p>
                <p class="metric-value highlight-green" id="metricCurrentRed">0 A</p>
                <p class="text-sm text-slate-500">Less stress on grid</p>
            </div>
            <div>
                <p class="metric-label">Peak Temp Reduction</p>
                <p class="metric-value highlight-green" id="metricTempRed">0 ¬∞C</p>
                <p class="text-sm text-slate-500">Extended line life</p>
            </div>
            <div>
                <p class="metric-label">Est. Line Loss Savings</p>
                <p class="metric-value text-[#4E80EE]" id="metricSavings">0 kWh/day</p>
                <p class="text-sm text-slate-500">Reduced I¬≤R Losses</p>
            </div>
            <div>
                <p class="metric-label">Total Generation Required</p>
                <p class="metric-value text-slate-200" id="metricTotalEnergy">0 kWh</p>
                <p class="text-sm text-slate-500">Base: <span id="valBaseEnergy">0</span> | Opt: <span id="valOptEnergy">0</span></p>
            </div>
        </div>
    </div>

    <!-- Main Dashboard -->
    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">

        <!-- Section 1: 1000kV Transmission Line -->
        <div class="col-span-1 lg:col-span-2">
            <h2 class="text-xl font-bold mb-4 text-slate-200 border-b border-slate-800 pb-2">Transmission Line (JL/G1A-630/45 ACSR 1000kV UHVAC)</h2>
        </div>

        <div class="card">
            <h3 class="text-lg font-semibold mb-4 text-white">Current Load (Amps)</h3>
            <canvas id="chartTransCurrent"></canvas>
        </div>

        <div class="card">
            <h3 class="text-lg font-semibold mb-4 text-white">Conductor Temperature (¬∞C)</h3>
            <canvas id="chartTransTemp"></canvas>
        </div>

        <!-- Section 2: 35kV Distribution Line -->
        <div class="col-span-1 lg:col-span-2 mt-4">
            <h2 class="text-xl font-bold mb-4 text-slate-200 border-b border-slate-800 pb-2">Distribution Line (YJV22-26/35-3√ó400mm¬≤ 35kV)</h2>
        </div>

        <div class="card">
            <h3 class="text-lg font-semibold mb-4 text-white">Current Load (Amps)</h3>
            <canvas id="chartDistCurrent"></canvas>
        </div>

        <div class="card">
            <h3 class="text-lg font-semibold mb-4 text-white">Conductor Temperature (¬∞C)</h3>
            <canvas id="chartDistTemp"></canvas>
        </div>

    </div>

    <script>
        // --- Dark Mode Chart Configuration ---
        Chart.defaults.color = '#94a3b8';
        Chart.defaults.borderColor = '#334155';

        // --- Global Weather Data State ---
        let weatherData = {
            temp: new Array(24).fill(25), // Default 25C
            wind: new Array(24).fill(0.61), // Default 0.61 m/s
            solar: new Array(24).fill(500) // Default 500 W/m2 (averaged)
        };
        let useLiveData = false;

        // --- Weather API Functions ---
        
        /**
         * Helper: Forward Fill for null/NaN values
         */
        function smoothData(data, defaultValue) {
            let smoothed = [];
            let lastValid = defaultValue;
            for (let i = 0; i < data.length; i++) {
                let val = data[i];
                if (val === null || val === undefined || isNaN(val)) {
                    val = lastValid;
                } else {
                    lastValid = val;
                }
                smoothed.push(val);
            }
            return smoothed;
        }

        async function fetchWeatherData() {
            const city = document.getElementById('cityInput').value;
            const statusEl = document.getElementById('locationStatus');
            
            if (!city) {
                statusEl.innerText = "Please enter a city name.";
                return;
            }

            statusEl.innerText = "Searching for location...";
            
            try {
                // 1. Geocoding
                const geoUrl = `https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(city)}&count=1&language=en&format=json`;
                const geoRes = await fetch(geoUrl);
                const geoData = await geoRes.json();

                if (!geoData.results || geoData.results.length === 0) {
                    statusEl.innerText = "City not found.";
                    return;
                }

                const { latitude, longitude, name, country } = geoData.results[0];
                statusEl.innerText = `Found: ${name}, ${country}. Fetching forecast...`;

                // 2. Weather Data (Forecast for today)
                // Added timezone=auto to align weather data with local 00:00-23:00 cycle
                const weatherUrl = `https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&hourly=temperature_2m,wind_speed_10m,shortwave_radiation&forecast_days=1&timezone=auto`;
                const weatherRes = await fetch(weatherUrl);
                const wData = await weatherRes.json();

                // Process Data with Forward Fill (Smoothing)
                weatherData.temp = smoothData(wData.hourly.temperature_2m.slice(0, 24), 25);
                // Convert km/h to m/s before smoothing
                const windMs = wData.hourly.wind_speed_10m.slice(0, 24).map(w => (w !== null && w !== undefined) ? w / 3.6 : null);
                weatherData.wind = smoothData(windMs, 0.61);
                weatherData.solar = smoothData(wData.hourly.shortwave_radiation.slice(0, 24), 0);

                useLiveData = true;
                
                // Update UI Summary
                const avgTemp = (weatherData.temp.reduce((a,b)=>a+b,0)/24).toFixed(1);
                const avgWind = (weatherData.wind.reduce((a,b)=>a+b,0)/24).toFixed(1);
                document.getElementById('weatherSummary').innerHTML = `
                    <strong class="text-white">${name}</strong> (Next 24h Avg):<br>
                    Temp: ${avgTemp}¬∞C | Wind: ${avgWind} m/s | Solar: Variable
                `;
                statusEl.innerText = "Weather data loaded. Simulation updated.";
                statusEl.className = "text-sm text-[#10b981] mt-1";

                updateSimulation();

            } catch (error) {
                console.error(error);
                statusEl.innerText = "Error fetching data. Please try again.";
                statusEl.className = "text-sm text-[#ef4444] mt-1";
            }
        }


        // --- Physics Engine ---

        // Constants
        const PI = Math.PI;

        function calculateCurrent(powerKw, voltageKv, type = 'AC', powerFactor = 0.95) {
            if (type === 'DC') {
                return (powerKw * 1000) / (2 * (voltageKv * 1000));
            }
            return (powerKw * 1000) / (Math.sqrt(3) * (voltageKv * 1000) * powerFactor);
        }

        function calculateResistance(r20, tempC, material = 'Al') {
            const alpha = material === 'Cu' ? 0.00393 : 0.00403;
            return r20 * (1 + alpha * (tempC - 20));
        }

        /**
         * IEEE 738 Steady-State Thermal Balance Solver
         */
        function solveTemperature(current, r20_per_km, diameter_mm, params, env, hourIdx, tempCorrection = 0) {
            
            let Ta = 25;
            let V_wind = 0.61;
            let Qs_flux = 500;

            if (useLiveData) {
                if (weatherData.temp && weatherData.temp[hourIdx] !== undefined && weatherData.temp[hourIdx] !== null) {
                    Ta = weatherData.temp[hourIdx];
                }
                if (weatherData.wind && weatherData.wind[hourIdx] !== undefined && weatherData.wind[hourIdx] !== null) {
                    V_wind = weatherData.wind[hourIdx];
                }
                if (weatherData.solar && weatherData.solar[hourIdx] !== undefined && weatherData.solar[hourIdx] !== null) {
                    Qs_flux = weatherData.solar[hourIdx];
                }
            } else {
                Ta = env.ambientTemp;
                V_wind = env.windSpeed;
                Qs_flux = env.solarRadiation;
            }

            if (isNaN(Ta)) Ta = 25;
            if (isNaN(V_wind)) V_wind = 0.61;
            if (isNaN(Qs_flux)) Qs_flux = 0;
            
            Ta += tempCorrection;

            let Tc = Ta; 
            const tolerance = 0.1;
            const maxIter = 100;
            
            const D = diameter_mm / 1000;
            const epsilon = params.emissivity;
            const alpha_solar = params.absorptivity;
            const Q_s = alpha_solar * Qs_flux * D; 

            for(let i=0; i<maxIter; i++) {
                const R_km = calculateResistance(r20_per_km, Tc, params.material);
                const R_m = R_km / 1000;
                const Q_j = current * current * R_m;
                
                const sigma = 5.67e-8;
                let T_kelvin = Tc + 273.15;
                if (T_kelvin < 0) T_kelvin = 0;
                
                const Q_r = sigma * epsilon * PI * D * (Math.pow(T_kelvin, 4) - Math.pow(Ta + 273.15, 4));
                
                const Tf = (Tc + Ta) / 2; 
                const rho_air = 1.225 * (293 / (Tf + 273.15));
                const mu_air = 1.8e-5;
                const k_air = 0.026;
                
                let Q_c = 0;
                if (V_wind > 0) {
                    const Re = (rho_air * V_wind * D) / mu_air;
                    const Nu = 0.683 * Math.pow(Re, 0.466);
                    const h = (Nu * k_air) / D;
                    Q_c = h * PI * D * (Tc - Ta);
                } else {
                    Q_c = 3.0 * Math.pow(D, 0.75) * Math.pow(Math.abs(Tc - Ta), 1.25);
                }

                const error = (Q_j + Q_s) - (Q_c + Q_r);
                
                let step = error * 0.5;
                if (step > 50) step = 50;
                if (step < -50) step = -50;
                
                Tc = Tc + step;
                if(Math.abs(error) < tolerance) break;
            }
            if (isNaN(Tc)) return Ta;
            return Tc;
        }

        function calculateCurrentForTargetTemp(targetTc, r20_per_km, diameter_mm, params, env, hourIdx, tempCorrection = 0) {
            let Ta = 25;
            let V_wind = 0.61;
            let Qs_flux = 500;

            if (useLiveData) {
                if (weatherData.temp && weatherData.temp[hourIdx] !== undefined) Ta = weatherData.temp[hourIdx];
                if (weatherData.wind && weatherData.wind[hourIdx] !== undefined) V_wind = weatherData.wind[hourIdx];
                if (weatherData.solar && weatherData.solar[hourIdx] !== undefined) Qs_flux = weatherData.solar[hourIdx];
            } else {
                Ta = env.ambientTemp;
                V_wind = env.windSpeed;
                Qs_flux = env.solarRadiation;
            }

            Ta += tempCorrection;
            const D = diameter_mm / 1000;
            const epsilon = params.emissivity;
            const alpha_solar = params.absorptivity;
            const Q_s = alpha_solar * Qs_flux * D;
            const R_km = calculateResistance(r20_per_km, targetTc, params.material);
            const R_m = R_km / 1000;

            const sigma = 5.67e-8;
            let T_kelvin = targetTc + 273.15;
            const Q_r = sigma * epsilon * PI * D * (Math.pow(T_kelvin, 4) - Math.pow(Ta + 273.15, 4));

            const Tf = (targetTc + Ta) / 2;
            const rho_air = 1.225 * (293 / (Tf + 273.15));
            const mu_air = 1.8e-5;
            const k_air = 0.026;

            let Q_c = 0;
            if (V_wind > 0) {
                const Re = (rho_air * V_wind * D) / mu_air;
                const Nu = 0.683 * Math.pow(Re, 0.466);
                const h = (Nu * k_air) / D;
                Q_c = h * PI * D * (targetTc - Ta);
            } else {
                Q_c = 3.0 * Math.pow(D, 0.75) * Math.pow(Math.abs(targetTc - Ta), 1.25);
            }

            const Q_j_required = Q_c + Q_r - Q_s;

            if (Q_j_required <= 0) return 0;
            return Math.sqrt(Q_j_required / R_m);
        }

        // --- Chart Management ---
        let charts = {};
        let simResultsGlobal = null;

        function initChart(canvasId, label, color, type) {
            const ctx = document.getElementById(canvasId).getContext('2d');
            return new Chart(ctx, {
                type: 'line',
                data: {
                    labels: SIM_DATA.hours.map(h => `${h}:00`),
                    datasets: [
                        {
                            label: 'Baseline (Without Product)',
                            borderColor: '#64748b', // Slate 500 for baseline in dark mode
                            borderDash: [5, 5],
                            data: [],
                            tension: 0.4
                        },
                        {
                            label: 'Isothermal (Constant Temp)',
                            borderColor: color,
                            backgroundColor: color + '20',
                            fill: true,
                            data: [],
                            tension: 0.1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    interaction: { mode: 'index', intersect: false },
                    scales: { 
                        y: { 
                            beginAtZero: false,
                            grid: { color: '#334155' } // Darker grid lines
                        },
                        x: {
                            grid: { color: '#334155' }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                afterBody: function(context) {
                                    if (label === 'Temp' && simResultsGlobal) {
                                        const idx = context[0].dataIndex;
                                        let ta = 25, wind = 0.61;
                                        if (useLiveData && weatherData.temp && weatherData.wind) {
                                            ta = weatherData.temp[idx] !== undefined ? weatherData.temp[idx].toFixed(1) : 'N/A';
                                            wind = weatherData.wind[idx] !== undefined ? weatherData.wind[idx].toFixed(1) : 'N/A';
                                        }
                                        return [
                                            `Ambient Temp: ${ta} ¬∞C`,
                                            `Wind Speed: ${wind} m/s`,
                                            `Solar Rad: ${weatherData.solar[idx] || 0} W/m¬≤`
                                        ];
                                    }
                                    return [];
                                }
                            }
                        },
                        legend: {
                            labels: { color: '#e2e8f0' }
                        }
                    }
                }
            });
        }

        // --- Main Simulation Loop ---
        function updateSimulation() {
            if(document.getElementById('gridScaleInput')) {
                const scale = parseInt(document.getElementById('gridScaleInput').value);
                if(!isNaN(scale) && scale > 0) {
                    SIM_DATA.scale_transmission = scale;
                }
            }

            const originalTotal = SIM_DATA.baseline_household_kw.reduce((a,b)=>a+b,0);
            let targetTotal = originalTotal;
            if(document.getElementById('dailyUsageInput')) {
                const val = parseFloat(document.getElementById('dailyUsageInput').value);
                if (!isNaN(val) && val > 0) targetTotal = val;
            }
            const loadScaleFactor = targetTotal / originalTotal;
            const currentBaselineKw = SIM_DATA.baseline_household_kw.map(kw => kw * loadScaleFactor);

            const envFallback = { ambientTemp: 25, windSpeed: 0.61, solarRadiation: 500 };
            const pTrans = SIM_DATA.line_params.transmission;
            const pDist = SIM_DATA.line_params.distribution;

            const baseLoadTrans = currentBaselineKw.map(kw => kw * SIM_DATA.scale_transmission);
            const baseLoadDist = currentBaselineKw.map(kw => kw * SIM_DATA.scale_distribution);

            const results = {
                trans: { baseI: [], optI: [], baseT: [], optT: [] },
                dist: { baseI: [], optI: [], baseT: [], optT: [] }
            };
            simResultsGlobal = results;
            let totalBaseEnergy = 0;

            for(let i=0; i<24; i++) {
                let I_total_base = calculateCurrent(baseLoadTrans[i], pTrans.voltage_kv, 'AC');
                let I_sub_base = I_total_base / pTrans.num_bundle;
                results.trans.baseI.push(I_total_base);
                let Tc_base = solveTemperature(I_sub_base, pTrans.resistance_dc_20_per_km_single, pTrans.diameter_mm, {emissivity: pTrans.emissivity, absorptivity: pTrans.absorptivity, material: 'Al'}, envFallback, i, -3);
                results.trans.baseT.push(Tc_base);

                let I_base_dist = calculateCurrent(baseLoadDist[i], pDist.voltage_kv, 'AC');
                results.dist.baseI.push(I_base_dist);
                let Tc_base_dist = solveTemperature(I_base_dist, pDist.resistance_dc_20_per_km, pDist.diameter_mm, {emissivity: pDist.emissivity, absorptivity: pDist.absorptivity, material: 'Al'}, envFallback, i);
                results.dist.baseT.push(Tc_base_dist);
                totalBaseEnergy += baseLoadTrans[i];
            }

            const BATTERY_CAP_KWH = parseFloat(document.getElementById('batteryCapInput').value) || 15;
            const BATTERY_EFF = 0.95;
            let minT = -50, maxT = 150, targetT = 25;
            let idealIsoCurrents = [];

            for(let iter=0; iter<20; iter++) {
                targetT = (minT + maxT) / 2;
                let currentSumPower = 0;
                let tempProfile = [];

                for(let i=0; i<24; i++) {
                    let I_sub_req = calculateCurrentForTargetTemp(targetT, pTrans.resistance_dc_20_per_km_single, pTrans.diameter_mm, {emissivity: pTrans.emissivity, absorptivity: pTrans.absorptivity, material: 'Al'}, envFallback, i, -3);
                    let I_total_req = I_sub_req * pTrans.num_bundle;
                    tempProfile.push(I_total_req);
                    let P_req = (Math.sqrt(3) * pTrans.voltage_kv * 1000 * I_total_req * 0.95) / 1000;
                    currentSumPower += P_req;
                }
                if (currentSumPower > totalBaseEnergy) maxT = targetT; else minT = targetT;
                idealIsoCurrents = tempProfile;
            }

            function runBatteryLoop(offsetKw = 0) {
                let currents = [];
                let soc = 0.5 * BATTERY_CAP_KWH;
                for(let i=0; i<24; i++) {
                    const baseP_total = (Math.sqrt(3) * pTrans.voltage_kv * 1000 * results.trans.baseI[i] * 0.95) / 1000;
                    const idealP_total = (Math.sqrt(3) * pTrans.voltage_kv * 1000 * idealIsoCurrents[i] * 0.95) / 1000;
                    const baseP_hh = baseP_total / SIM_DATA.scale_transmission;
                    const idealP_hh = idealP_total / SIM_DATA.scale_transmission;
                    let targetP_hh = idealP_hh + offsetKw;
                    let actualP_hh = baseP_hh;
                    let powerDiff = targetP_hh - baseP_hh;
                    if (powerDiff > 0) {
                        const spaceLeft = BATTERY_CAP_KWH - soc;
                        const maxCharge = spaceLeft / BATTERY_EFF;
                        const actualCharge = Math.min(powerDiff, maxCharge);
                        soc += actualCharge * BATTERY_EFF;
                        actualP_hh = baseP_hh + actualCharge;
                    } else {
                        const dischargeNeeded = -powerDiff; 
                        const effOneWay = Math.sqrt(BATTERY_EFF);
                        const maxOutput = soc * effOneWay;
                        const actualOutput = Math.min(dischargeNeeded, maxOutput);
                        soc -= actualOutput / effOneWay;
                        actualP_hh = baseP_hh - actualOutput;
                    }
                    const actualP_total = actualP_hh * SIM_DATA.scale_transmission;
                    const actualI_total = calculateCurrent(actualP_total, pTrans.voltage_kv, 'AC');
                    currents.push(actualI_total);
                }
                return { currents, finalSoc: soc };
            }

            let run1 = runBatteryLoop(0);
            let startSoc = 0.5 * BATTERY_CAP_KWH;
            let netDrain = startSoc - run1.finalSoc;
            let correctionKw = netDrain / 24;
            let run2 = runBatteryLoop(correctionKw);
            let finalOptCurrents = run2.currents;
            let finalSoc = run2.finalSoc;
            let finalNetDrain = startSoc - finalSoc;
            const gridEnergyCorrectionPerHH = finalNetDrain > 0 ? (finalNetDrain / BATTERY_EFF) : 0;
            const totalCorrectionKwh = gridEnergyCorrectionPerHH * SIM_DATA.scale_transmission;

            for(let i=0; i<24; i++) {
                let I_iso = finalOptCurrents[i];
                results.trans.optI.push(I_iso);
                let I_sub_iso = I_iso / pTrans.num_bundle;
                let Tc_iso = solveTemperature(I_sub_iso, pTrans.resistance_dc_20_per_km_single, pTrans.diameter_mm, {emissivity: pTrans.emissivity, absorptivity: pTrans.absorptivity, material: 'Al'}, envFallback, i, -3);
                results.trans.optT.push(Tc_iso);
                let ratio = I_iso / results.trans.baseI[i];
                if(isNaN(ratio)) ratio = 1;
                let I_dist_iso = results.dist.baseI[i] * ratio; 
                results.dist.optI.push(I_dist_iso);
                let Tc_dist_iso = solveTemperature(I_dist_iso, pDist.resistance_dc_20_per_km, pDist.diameter_mm, {emissivity: pDist.emissivity, absorptivity: pDist.absorptivity, material: 'Al'}, envFallback, i);
                results.dist.optT.push(Tc_dist_iso);
            }

            updateChartData(charts.transCurrent, results.trans.baseI, results.trans.optI);
            updateChartData(charts.transTemp, results.trans.baseT, results.trans.optT);
            updateChartData(charts.distCurrent, results.dist.baseI, results.dist.optI);
            updateChartData(charts.distTemp, results.dist.baseT, results.dist.optT);

            const maxBaseI = Math.max(...results.trans.baseI);
            const maxOptI = Math.max(...results.trans.optI);
            const currentRed = maxBaseI - maxOptI;
            const maxBaseT = Math.max(...results.trans.baseT);
            const maxOptT = Math.max(...results.trans.optT);
            let tempRed = maxBaseT - maxOptT;
            
            let lossTransBaseTotal = 0, lossTransOptTotal = 0, lossDistBaseTotal = 0, lossDistOptTotal = 0;
            const LENGTH_TRANS_KM = parseFloat(document.getElementById('transLenSlider').value) || 1000;
            const LENGTH_DIST_KM = parseFloat(document.getElementById('distLenSlider').value) || 20;

            for(let i=0; i<24; i++) {
                let R_single_base = calculateResistance(pTrans.resistance_dc_20_per_km_single, results.trans.baseT[i], 'Al');
                let R_single_opt = calculateResistance(pTrans.resistance_dc_20_per_km_single, results.trans.optT[i], 'Al');
                let I_sub_base = results.trans.baseI[i] / pTrans.num_bundle;
                let I_sub_opt = results.trans.optI[i] / pTrans.num_bundle;
                let loss_trans_base = 3 * pTrans.num_bundle * Math.pow(I_sub_base, 2) * R_single_base * LENGTH_TRANS_KM;
                let loss_trans_opt = 3 * pTrans.num_bundle * Math.pow(I_sub_opt, 2) * R_single_opt * LENGTH_TRANS_KM;
                lossTransBaseTotal += loss_trans_base;
                lossTransOptTotal += loss_trans_opt;

                let R_dist_base = calculateResistance(pDist.resistance_dc_20_per_km, results.dist.baseT[i], 'Al');
                let R_dist_opt = calculateResistance(pDist.resistance_dc_20_per_km, results.dist.optT[i], 'Al');
                let loss_dist_base = 3 * Math.pow(results.dist.baseI[i], 2) * R_dist_base * LENGTH_DIST_KM;
                let loss_dist_opt = 3 * Math.pow(results.dist.optI[i], 2) * R_dist_opt * LENGTH_DIST_KM;
                lossDistBaseTotal += loss_dist_base;
                lossDistOptTotal += loss_dist_opt;
            }

            const lossBase = lossTransBaseTotal + lossDistBaseTotal;
            const lossOpt = lossTransOptTotal + lossDistOptTotal;
            const savingsKwh = (lossBase - lossOpt) / 1000;

            const savingsTransKwh = (lossTransBaseTotal - lossTransOptTotal) / 1000;
            const savingsDistKwh = (lossDistBaseTotal - lossDistOptTotal) / 1000;
            
            document.getElementById('vizTransSavings').innerText = `${savingsTransKwh.toFixed(0)} kWh`;
            document.getElementById('vizDistSavings').innerText = `${savingsDistKwh.toFixed(0)} kWh`;
            document.getElementById('vizTransLen').innerText = `${LENGTH_TRANS_KM} km`;
            document.getElementById('vizDistLen').innerText = `${LENGTH_DIST_KM} km`;
            document.getElementById('vizTransVolt').innerText = `${pTrans.voltage_kv} kV`;
            document.getElementById('vizDistVolt').innerText = `${pDist.voltage_kv} kV`;

            const avgTemp = (weatherData.temp.reduce((a,b)=>a+b,0)/24).toFixed(1);
            const avgTransTemp = (parseFloat(avgTemp) - 3).toFixed(1);
            document.getElementById('vizTransWeather').innerText = `Avg Amb: ${avgTransTemp}¬∞C`;
            document.getElementById('vizDistWeather').innerText = `Avg Amb: ${avgTemp}¬∞C`;
            document.getElementById('vizHouseCount').innerText = `${SIM_DATA.scale_transmission.toLocaleString()} Users`;

            const totalOptKwhCalc = finalOptCurrents.reduce((acc, I) => {
                 return acc + (Math.sqrt(3) * pTrans.voltage_kv * 1000 * I * 0.95) / 1000;
            }, 0);
            
            const adjustedTotalOptKwh = totalOptKwhCalc + totalCorrectionKwh;
            const baseTotalGenKwh = totalBaseEnergy + (lossBase / 1000);
            const optTotalGenKwh = adjustedTotalOptKwh + (lossOpt / 1000);
            const diffKwh = optTotalGenKwh - baseTotalGenKwh;
            const pctDiff = (diffKwh / baseTotalGenKwh) * 100;

            document.getElementById('metricCurrentRed').innerText = `${currentRed.toFixed(1)} A`;
            document.getElementById('metricTempRed').innerText = `${tempRed.toFixed(1)} ¬∞C`;
            document.getElementById('metricSavings').innerText = `${savingsKwh.toFixed(0)} kWh`;
            
            document.getElementById('metricTotalEnergy').innerText = `${pctDiff > 0 ? '+' : ''}${pctDiff.toFixed(2)}%`;
            document.getElementById('metricTotalEnergy').className = pctDiff > 0 ? "metric-value text-[#ef4444]" : "metric-value text-[#10b981]";
            
            const fmt = (num) => {
                if(num > 1e6) return (num/1e6).toFixed(2) + ' M';
                if(num > 1e3) return (num/1e3).toFixed(2) + ' k';
                return num.toFixed(0);
            };

            document.getElementById('valBaseEnergy').innerText = fmt(baseTotalGenKwh);
            document.getElementById('valOptEnergy').innerText = fmt(optTotalGenKwh);
            
            if(document.getElementById('householdCountDisplay')) {
                const num = SIM_DATA.scale_transmission;
                const fmtNum = num > 1e6 ? (num/1e6).toFixed(2) + ' M' : (num/1e3).toFixed(0) + ' k';
                document.getElementById('householdCountDisplay').innerText = fmtNum;
            }
            
            document.getElementById('vizHouseCount').innerText = `${SIM_DATA.scale_transmission > 1e6 ? (SIM_DATA.scale_transmission/1e6).toFixed(2)+' M' : (SIM_DATA.scale_transmission/1e3).toFixed(0)+' k'} Users`;
        }

        function updateChartData(chart, dataBase, dataOpt) {
            chart.data.datasets[0].data = dataBase;
            chart.data.datasets[1].data = dataOpt;
            chart.update();
        }

        function computeNetSavingsForCap(cap) {
            const envFallback = { ambientTemp: 25, windSpeed: 0.61, solarRadiation: 500 };
            const pTrans = SIM_DATA.line_params.transmission;
            const pDist = SIM_DATA.line_params.distribution;
            
            const originalTotal = SIM_DATA.baseline_household_kw.reduce((a,b)=>a+b,0);
            let targetTotal = originalTotal;
            if(document.getElementById('dailyUsageInput')) {
                const val = parseFloat(document.getElementById('dailyUsageInput').value);
                if (!isNaN(val) && val > 0) targetTotal = val;
            }
            const loadScaleFactor = targetTotal / originalTotal;
            const currentBaselineKw = SIM_DATA.baseline_household_kw.map(kw => kw * loadScaleFactor);

            const baseLoadTrans = currentBaselineKw.map(kw => kw * SIM_DATA.scale_transmission);
            const baseLoadDist = currentBaselineKw.map(kw => kw * SIM_DATA.scale_distribution);
            const resultsLocal = { trans: { baseI: [], baseT: [] }, dist: { baseI: [], baseT: [] } };
            let totalBaseEnergy = 0;
            for (let i = 0; i < 24; i++) {
                const I_total_base = calculateCurrent(baseLoadTrans[i], pTrans.voltage_kv, 'AC');
                const I_sub_base = I_total_base / pTrans.num_bundle;
                resultsLocal.trans.baseI.push(I_total_base);
                const Tc_base = solveTemperature(I_sub_base, pTrans.resistance_dc_20_per_km_single, pTrans.diameter_mm, { emissivity: pTrans.emissivity, absorptivity: pTrans.absorptivity, material: 'Al' }, envFallback, i, -3);
                resultsLocal.trans.baseT.push(Tc_base);
                const I_base_dist = calculateCurrent(baseLoadDist[i], pDist.voltage_kv, 'AC');
                resultsLocal.dist.baseI.push(I_base_dist);
                const Tc_base_dist = solveTemperature(I_base_dist, pDist.resistance_dc_20_per_km, pDist.diameter_mm, { emissivity: pDist.emissivity, absorptivity: pDist.absorptivity, material: 'Al' }, envFallback, i);
                resultsLocal.dist.baseT.push(Tc_base_dist);
                totalBaseEnergy += baseLoadTrans[i];
            }
            const BATTERY_CAP_KWH = cap;
            const BATTERY_EFF = 0.95;
            let minT = -50, maxT = 150, targetT = 25;
            let idealIsoCurrents = [];
            for (let iter = 0; iter < 20; iter++) {
                targetT = (minT + maxT) / 2;
                let currentSumPower = 0;
                let tempProfile = [];
                for (let i = 0; i < 24; i++) {
                    const I_sub_req = calculateCurrentForTargetTemp(targetT, pTrans.resistance_dc_20_per_km_single, pTrans.diameter_mm, { emissivity: pTrans.emissivity, absorptivity: pTrans.absorptivity, material: 'Al' }, envFallback, i, -3);
                    const I_total_req = I_sub_req * pTrans.num_bundle;
                    tempProfile.push(I_total_req);
                    const P_req = (Math.sqrt(3) * pTrans.voltage_kv * 1000 * I_total_req * 0.95) / 1000;
                    currentSumPower += P_req;
                }
                if (currentSumPower > totalBaseEnergy) maxT = targetT; else minT = targetT;
                idealIsoCurrents = tempProfile;
            }
            function runBatteryLoopLocal(offsetKw) {
                let currents = [];
                let soc = 0.5 * BATTERY_CAP_KWH;
                for (let i = 0; i < 24; i++) {
                    const baseP_total = (Math.sqrt(3) * pTrans.voltage_kv * 1000 * resultsLocal.trans.baseI[i] * 0.95) / 1000;
                    const idealP_total = (Math.sqrt(3) * pTrans.voltage_kv * 1000 * idealIsoCurrents[i] * 0.95) / 1000;
                    const baseP_hh = baseP_total / SIM_DATA.scale_transmission;
                    const idealP_hh = idealP_total / SIM_DATA.scale_transmission;
                    const targetP_hh = idealP_hh + offsetKw;
                    let actualP_hh = baseP_hh;
                    const powerDiff = targetP_hh - baseP_hh;
                    if (powerDiff > 0) {
                        const spaceLeft = BATTERY_CAP_KWH - soc;
                        const maxCharge = spaceLeft / BATTERY_EFF;
                        const actualCharge = Math.min(powerDiff, maxCharge);
                        soc += actualCharge * BATTERY_EFF;
                        actualP_hh = baseP_hh + actualCharge;
                    } else {
                        const dischargeNeeded = -powerDiff;
                        const effOneWay = Math.sqrt(BATTERY_EFF);
                        const maxOutput = soc * effOneWay;
                        const actualOutput = Math.min(dischargeNeeded, maxOutput);
                        soc -= actualOutput / effOneWay;
                        actualP_hh = baseP_hh - actualOutput;
                    }
                    const actualP_total = actualP_hh * SIM_DATA.scale_transmission;
                    const actualI_total = calculateCurrent(actualP_total, pTrans.voltage_kv, 'AC');
                    currents.push(actualI_total);
                }
                return { currents, finalSoc: soc };
            }
            const run1 = runBatteryLoopLocal(0);
            const startSoc = 0.5 * BATTERY_CAP_KWH;
            const netDrain = startSoc - run1.finalSoc;
            const correctionKw = netDrain / 24;
            const run2 = runBatteryLoopLocal(correctionKw);
            const finalOptCurrents = run2.currents;
            const finalSoc = run2.finalSoc;
            const finalNetDrain = startSoc - finalSoc;
            const gridEnergyCorrectionPerHH = finalNetDrain > 0 ? (finalNetDrain / BATTERY_EFF) : 0;
            const totalCorrectionKwh = gridEnergyCorrectionPerHH * SIM_DATA.scale_transmission;
            let lossTransBaseTotal = 0, lossTransOptTotal = 0, lossDistBaseTotal = 0, lossDistOptTotal = 0;
            for (let i = 0; i < 24; i++) {
                const R_single_base = calculateResistance(pTrans.resistance_dc_20_per_km_single, resultsLocal.trans.baseT[i], 'Al');
                const I_sub_base = resultsLocal.trans.baseI[i] / pTrans.num_bundle;
                const I_sub_opt = finalOptCurrents[i] / pTrans.num_bundle;
                const Tc_opt = solveTemperature(I_sub_opt, pTrans.resistance_dc_20_per_km_single, pTrans.diameter_mm, { emissivity: pTrans.emissivity, absorptivity: pTrans.absorptivity, material: 'Al' }, envFallback, i, -3);
                const R_single_opt = calculateResistance(pTrans.resistance_dc_20_per_km_single, Tc_opt, 'Al');
                lossTransBaseTotal += 3 * pTrans.num_bundle * Math.pow(I_sub_base, 2) * R_single_base * (parseFloat(document.getElementById('transLenSlider').value) || 1000);
                lossTransOptTotal += 3 * pTrans.num_bundle * Math.pow(I_sub_opt, 2) * R_single_opt * (parseFloat(document.getElementById('transLenSlider').value) || 1000);
                const R_dist_base = calculateResistance(pDist.resistance_dc_20_per_km, resultsLocal.dist.baseT[i], 'Al');
                const ratio = finalOptCurrents[i] / resultsLocal.trans.baseI[i];
                const I_dist_opt = resultsLocal.dist.baseI[i] * (isNaN(ratio) ? 1 : ratio);
                const Tc_dist_opt = solveTemperature(I_dist_opt, pDist.resistance_dc_20_per_km, pDist.diameter_mm, { emissivity: pDist.emissivity, absorptivity: pDist.absorptivity, material: 'Al' }, envFallback, i);
                const R_dist_opt = calculateResistance(pDist.resistance_dc_20_per_km, Tc_dist_opt, 'Al');
                lossDistBaseTotal += 3 * Math.pow(resultsLocal.dist.baseI[i], 2) * R_dist_base * (parseFloat(document.getElementById('distLenSlider').value) || 20);
                lossDistOptTotal += 3 * Math.pow(I_dist_opt, 2) * R_dist_opt * (parseFloat(document.getElementById('distLenSlider').value) || 20);
            }
            const savingsKwh = (lossTransBaseTotal + lossDistBaseTotal - (lossTransOptTotal + lossDistOptTotal)) / 1000;
            const totalOptKwhCalc = finalOptCurrents.reduce((acc, I) => acc + (Math.sqrt(3) * pTrans.voltage_kv * 1000 * I * 0.95) / 1000, 0);
            const adjustedTotalOptKwh = totalOptKwhCalc + totalCorrectionKwh;
            const diffKwh = adjustedTotalOptKwh - totalBaseEnergy;
            const batteryPenalty = diffKwh > 0 ? diffKwh : 0;
            const netSaving = savingsKwh - batteryPenalty;
            return { netSaving };
        }

        function findOptimalBatteryCapacity() {
            let bestCap = 5;
            let bestNet = -1e9;
            for (let c = 5; c <= 50; c += 0.5) {
                const res = computeNetSavingsForCap(parseFloat((Math.round(c*2)/2).toFixed(1)));
                if (res.netSaving > bestNet) { bestNet = res.netSaving; bestCap = parseFloat((Math.round(c*2)/2).toFixed(1)); }
            }
            const snapped = parseFloat((Math.round(bestCap*2)/2).toFixed(1));
            const resFinal = computeNetSavingsForCap(snapped);
            document.getElementById('batteryCapInput').value = snapped;
            document.getElementById('batteryCapVal').innerText = snapped + ' kWh';
            document.getElementById('optimalCapVal').innerText = 'Optimal ' + snapped + ' kWh, net saving ' + resFinal.netSaving.toFixed(0) + ' kWh';
            updateSimulation();
        }

        function findOptimalBatteryEfficiency() {
            let bestCap = 1;
            let bestRatio = -1e9;
            for (let c = 1; c <= 50; c += 0.5) {
                const res = computeNetSavingsForCap(parseFloat(c.toFixed(1)));
                if (c > 0) {
                     let ratio = res.netSaving / c;
                     if (ratio > bestRatio) { 
                        bestRatio = ratio; 
                        bestCap = parseFloat(c.toFixed(1)); 
                    }
                }
            }
            const snapped = bestCap;
            const resFinal = computeNetSavingsForCap(snapped);
            const finalRatio = resFinal.netSaving / snapped;
            document.getElementById('batteryCapInput').value = snapped;
            document.getElementById('batteryCapVal').innerText = snapped + ' kWh';
            document.getElementById('optimalEffVal').innerText = `Opt: ${snapped} kWh (${finalRatio.toFixed(2)} kWh/kWh)`;
            updateSimulation();
        }

        window.onload = function() {
            charts.transCurrent = initChart('chartTransCurrent', 'Current', '#4E80EE');
            charts.transTemp = initChart('chartTransTemp', 'Temp', '#ef4444');
            charts.distCurrent = initChart('chartDistCurrent', 'Current', '#4E80EE');
            charts.distTemp = initChart('chartDistTemp', 'Temp', '#ef4444');
            updateSimulation();
        };

    </script>
</body>
</html>
