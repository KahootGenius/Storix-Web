<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Storix Energy Saving Simulator</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js for visualization -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Load Simulation Data -->
    <script>
    const SIM_DATA = {
  "hours": [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23
  ],
  "baseline_household_kw": [
    0.5179,
    0.6539,
    0.3404,
    0.2694,
    0.3469,
    0.268,
    0.8976,
    2.3629,
    2.9729,
    1.9952,
    1.4271,
    3.9708,
    1.4308,
    0.5538,
    1.6954,
    1.2912,
    0.6835,
    1.8244,
    3.3644,
    3.1902,
    2.9339,
    1.6947,
    0.8519,
    0.3761
  ],
  "optimized_household_kw": [
    1.486321052631582,
    1.4960052631578973,
    1.4877684210526343,
    1.49045263157895,
    1.4942684210526342,
    1.4890526315789498,
    1.487073684210528,
    1.562900000000007,
    1.5629000000000204,
    1.5551999999999997,
    1.4902578947368423,
    1.5608000000000417,
    1.4939578947368424,
    1.4906421052631607,
    1.5554,
    1.4912000000000005,
    1.4940263157894762,
    1.5543999999999998,
    1.5544000000000284,
    1.560200000000025,
    1.5639000000000194,
    1.5547,
    1.4940052631578966,
    1.4918894736842132
  ],
  "scale_transmission": 2000000,
  "scale_distribution": 5000,
  "line_params": {
    "transmission": {
      "voltage_kv": 1000,
      "name": "JL/G1A-630/45 ACSR",
      "resistance_dc_20_per_km_single": 0.0459,
      "num_bundle": 8,
      "diameter_mm": 33.6,
      "emissivity": 0.5,
      "absorptivity": 0.5
    },
    "distribution": {
      "voltage_kv": 35,
      "name": "YJV22-26/35-3x400",
      "resistance_dc_20_per_km": 0.047,
      "diameter_mm": 40.0,
      "emissivity": 0.9,
      "absorptivity": 0.9
    }
  }
};
    </script>
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f8fafc; }
        .card { background: white; border-radius: 12px; padding: 20px; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1); margin-bottom: 20px; }
        .metric-value { font-size: 1.5rem; font-weight: 700; color: #0f172a; }
        .metric-label { font-size: 0.875rem; color: #64748b; }
        .highlight-green { color: #10b981; }
        .highlight-red { color: #ef4444; }
    </style>
</head>
<body class="p-6 max-w-7xl mx-auto">

    <!-- Header -->
    <div class="mb-8 text-center">
        <h1 class="text-3xl font-bold text-slate-800">Energy Saving & Transmission Simulator</h1>
        <p class="text-slate-500 mt-2">Visualizing the impact of Storix Battery Solution on Power Transmission Efficiency</p>
    </div>

    <!-- Controls -->
    <div class="card bg-white p-6 rounded-lg shadow-sm mb-6">
        <h3 class="text-lg font-semibold text-slate-800 mb-4">üìç Location & Weather Data</h3>
        
        <div class="grid grid-cols-1 md:grid-cols-4 gap-4 items-end">
            <div class="md:col-span-2">
                <label class="block text-sm font-medium text-slate-700">Search City</label>
                <div class="flex mt-1">
                    <input type="text" id="cityInput" placeholder="e.g. London, Tokyo, New York" class="flex-1 rounded-l-md border-gray-300 shadow-sm p-2 border focus:ring-blue-500 focus:border-blue-500">
                    <button onclick="fetchWeatherData()" class="bg-blue-600 text-white px-4 py-2 rounded-r-md hover:bg-blue-700 font-bold">
                        Fetch Weather
                    </button>
                </div>
                <p id="locationStatus" class="text-sm text-slate-500 mt-1">Enter a city to load real-time forecast data.</p>
            </div>
            
            <div class="bg-slate-50 p-3 rounded border text-sm">
                <p class="font-semibold text-slate-700">Current Forecast Data:</p>
                <div id="weatherSummary" class="mt-1 text-slate-600">
                    Using default constant values.
                </div>
            </div>

            <div>
                <label class="block text-sm font-medium text-slate-700">Grid Scale (Households)</label>
                <input type="number" id="gridScaleInput" value="2000000" step="100000" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 border" onchange="updateSimulation()">
            </div>

            <div class="md:col-span-4">
                 <button onclick="updateSimulation()" class="w-full bg-slate-200 text-slate-700 p-2 rounded-md hover:bg-slate-300 font-semibold">
                    Re-Run Simulation
                </button>
            </div>
        </div>
    </div>

    <!-- System Visualization -->
    <div class="card bg-white p-8 rounded-lg shadow-sm mb-6 overflow-hidden">
        <h3 class="text-lg font-semibold text-slate-800 mb-8">System Visualization & Savings Breakdown</h3>
        
        <div class="relative flex items-center justify-between min-w-[600px]">
            <!-- Connecting Line Background -->
            <div class="absolute top-1/2 left-0 w-full h-1 bg-gray-200 -z-10 -translate-y-1/2"></div>

            <!-- Node 1: Power Plant -->
            <div class="flex flex-col items-center bg-white px-2 z-10">
                <div class="w-16 h-16 bg-slate-100 rounded-full flex items-center justify-center text-3xl shadow-sm border border-slate-200 mb-2">
                    üè≠
                </div>
                <div class="font-bold text-slate-800">Power Plant</div>
                <div class="text-xs text-slate-500">Source</div>
            </div>

            <!-- Link 1: Transmission -->
            <div class="flex-1 flex flex-col items-center px-4">
                <div class="bg-blue-50 border border-blue-100 rounded px-3 py-1 mb-2 text-center shadow-sm w-full max-w-[200px]">
                    <div class="text-xs font-semibold text-blue-800 uppercase tracking-wider">Transmission Line</div>
                    <div class="text-lg font-bold text-green-600" id="vizTransSavings">0 kWh</div>
                    <div class="text-xs text-slate-500">Saved Today</div>
                </div>
                
                <!-- Controls for Trans Line -->
                <div class="w-full max-w-[200px] bg-white border border-slate-100 rounded p-2 mb-1">
                     <div class="flex justify-between text-xs text-slate-600 mb-1">
                        <span>Length</span>
                        <span id="vizTransLen">1000 km</span>
                    </div>
                    <input type="range" id="transLenSlider" min="100" max="5000" step="100" value="1000" class="w-full h-1 bg-gray-200 rounded-lg appearance-none cursor-pointer" oninput="updateSimulation()">
                </div>

                <div class="text-xs text-slate-400 bg-white px-2">
                    <span id="vizTransVolt">1000 kV</span>
                </div>
                <div class="text-xs text-slate-400 mt-1 bg-white px-2">
                    <span id="vizTransWeather">Temp: --</span>
                </div>
            </div>

            <!-- Node 2: Substation -->
            <div class="flex flex-col items-center bg-white px-2 z-10">
                <div class="w-16 h-16 bg-slate-100 rounded-full flex items-center justify-center text-3xl shadow-sm border border-slate-200 mb-2">
                    ‚ö°
                </div>
                <div class="font-bold text-slate-800">Substation</div>
                <div class="text-xs text-slate-500">Step Down</div>
            </div>

            <!-- Link 2: Distribution -->
            <div class="flex-1 flex flex-col items-center px-4">
                <div class="bg-blue-50 border border-blue-100 rounded px-3 py-1 mb-2 text-center shadow-sm w-full max-w-[200px]">
                    <div class="text-xs font-semibold text-blue-800 uppercase tracking-wider">Distribution Line</div>
                    <div class="text-lg font-bold text-green-600" id="vizDistSavings">0 kWh</div>
                    <div class="text-xs text-slate-500">Saved Today</div>
                </div>

                <!-- Controls for Dist Line -->
                <div class="w-full max-w-[200px] bg-white border border-slate-100 rounded p-2 mb-1">
                     <div class="flex justify-between text-xs text-slate-600 mb-1">
                        <span>Length</span>
                        <span id="vizDistLen">20 km</span>
                    </div>
                    <input type="range" id="distLenSlider" min="1" max="100" step="1" value="20" class="w-full h-1 bg-gray-200 rounded-lg appearance-none cursor-pointer" oninput="updateSimulation()">
                </div>

                <div class="text-xs text-slate-400 bg-white px-2">
                    <span id="vizDistVolt">35 kV</span>
                </div>
                <div class="text-xs text-slate-400 mt-1 bg-white px-2">
                    <span id="vizDistWeather">Temp: --</span>
                </div>
            </div>

            <!-- Node 3: Households -->
            <div class="flex flex-col items-center bg-white px-2 z-10">
                <div class="w-16 h-16 bg-slate-100 rounded-full flex items-center justify-center text-3xl shadow-sm border border-slate-200 mb-2">
                    üè†
                </div>
                <div class="font-bold text-slate-800">Households</div>
                <div class="text-xs text-slate-500" id="vizHouseCount">2M Users</div>
            </div>
        </div>
    </div>

    <!-- Main Dashboard -->
    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">

        <!-- Section 1: 1000kV Transmission Line -->
        <div class="col-span-1 lg:col-span-2">
            <h2 class="text-xl font-bold mb-4 text-slate-800 border-b pb-2">Transmission Line (JL/G1A-630/45 ACSR 1000kV UHVAC)</h2>
        </div>

        <div class="card">
            <h3 class="text-lg font-semibold mb-4">Current Load (Amps)</h3>
            <canvas id="chartTransCurrent"></canvas>
        </div>

        <div class="card">
            <h3 class="text-lg font-semibold mb-4">Conductor Temperature (¬∞C)</h3>
            <canvas id="chartTransTemp"></canvas>
        </div>

        <!-- Section 2: 35kV Distribution Line -->
        <div class="col-span-1 lg:col-span-2 mt-4">
            <h2 class="text-xl font-bold mb-4 text-slate-800 border-b pb-2">Distribution Line (YJV22-26/35-3√ó400mm¬≤ 35kV)</h2>
        </div>

        <div class="card">
            <h3 class="text-lg font-semibold mb-4">Current Load (Amps)</h3>
            <canvas id="chartDistCurrent"></canvas>
        </div>

        <div class="card">
            <h3 class="text-lg font-semibold mb-4">Conductor Temperature (¬∞C)</h3>
            <canvas id="chartDistTemp"></canvas>
        </div>

    </div>

    <!-- Summary Metrics -->
    <div class="card mt-6 bg-slate-50 border-blue-100 border">
        <div class="mb-4 border-b border-blue-200 pb-2">
            <h2 class="text-xl font-bold text-slate-800">Impact Summary</h2>
            <p class="text-slate-600 mt-1">
                Data scaled to represent a regional grid serving 
                <strong class="text-blue-700" id="householdCountDisplay">2,000,000</strong> households.
            </p>
        </div>
        <div class="grid grid-cols-1 md:grid-cols-4 gap-6">
            <div>
                <p class="metric-label">Peak Current Reduction</p>
                <p class="metric-value highlight-green" id="metricCurrentRed">0 A</p>
                <p class="text-sm text-slate-500">Less stress on grid</p>
            </div>
            <div>
                <p class="metric-label">Peak Temp Reduction</p>
                <p class="metric-value highlight-green" id="metricTempRed">0 ¬∞C</p>
                <p class="text-sm text-slate-500">Extended line life</p>
            </div>
            <div>
                <p class="metric-label">Est. Line Loss Savings</p>
                <p class="metric-value text-blue-600" id="metricSavings">0 kWh/day</p>
                <p class="text-sm text-slate-500">Reduced I¬≤R Losses</p>
            </div>
            <div>
                <p class="metric-label">Total Energy Draw</p>
                <p class="metric-value text-slate-800" id="metricTotalEnergy">0 kWh</p>
                <p class="text-sm text-slate-500">Base: <span id="valBaseEnergy">0</span> | Opt: <span id="valOptEnergy">0</span></p>
            </div>
        </div>

    </div>

    <script>
        // --- Global Weather Data State ---
        let weatherData = {
            temp: new Array(24).fill(25), // Default 25C
            wind: new Array(24).fill(0.61), // Default 0.61 m/s
            solar: new Array(24).fill(500) // Default 500 W/m2 (averaged)
        };
        let useLiveData = false;

        // --- Weather API Functions ---
        
        /**
         * Helper: Forward Fill for null/NaN values
         */
        function smoothData(data, defaultValue) {
            let smoothed = [];
            let lastValid = defaultValue;
            for (let i = 0; i < data.length; i++) {
                let val = data[i];
                if (val === null || val === undefined || isNaN(val)) {
                    val = lastValid;
                } else {
                    lastValid = val;
                }
                smoothed.push(val);
            }
            return smoothed;
        }

        async function fetchWeatherData() {
            const city = document.getElementById('cityInput').value;
            const statusEl = document.getElementById('locationStatus');
            
            if (!city) {
                statusEl.innerText = "Please enter a city name.";
                return;
            }

            statusEl.innerText = "Searching for location...";
            
            try {
                // 1. Geocoding
                const geoUrl = `https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(city)}&count=1&language=en&format=json`;
                const geoRes = await fetch(geoUrl);
                const geoData = await geoRes.json();

                if (!geoData.results || geoData.results.length === 0) {
                    statusEl.innerText = "City not found.";
                    return;
                }

                const { latitude, longitude, name, country } = geoData.results[0];
                statusEl.innerText = `Found: ${name}, ${country}. Fetching forecast...`;

                // 2. Weather Data (Forecast for today)
                // Added timezone=auto to align weather data with local 00:00-23:00 cycle
                const weatherUrl = `https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&hourly=temperature_2m,wind_speed_10m,shortwave_radiation&forecast_days=1&timezone=auto`;
                const weatherRes = await fetch(weatherUrl);
                const wData = await weatherRes.json();

                // Process Data with Forward Fill (Smoothing)
                weatherData.temp = smoothData(wData.hourly.temperature_2m.slice(0, 24), 25);
                // Convert km/h to m/s before smoothing
                const windMs = wData.hourly.wind_speed_10m.slice(0, 24).map(w => (w !== null && w !== undefined) ? w / 3.6 : null);
                weatherData.wind = smoothData(windMs, 0.61);
                weatherData.solar = smoothData(wData.hourly.shortwave_radiation.slice(0, 24), 0);

                useLiveData = true;
                
                // Update UI Summary
                const avgTemp = (weatherData.temp.reduce((a,b)=>a+b,0)/24).toFixed(1);
                const avgWind = (weatherData.wind.reduce((a,b)=>a+b,0)/24).toFixed(1);
                document.getElementById('weatherSummary').innerHTML = `
                    <strong>${name}</strong> (Next 24h Avg):<br>
                    Temp: ${avgTemp}¬∞C | Wind: ${avgWind} m/s | Solar: Variable
                `;
                statusEl.innerText = "Weather data loaded. Simulation updated.";
                statusEl.className = "text-sm text-green-600 mt-1";

                updateSimulation();

            } catch (error) {
                console.error(error);
                statusEl.innerText = "Error fetching data. Please try again.";
                statusEl.className = "text-sm text-red-600 mt-1";
            }
        }


        // --- Physics Engine ---

        // Constants
        const PI = Math.PI;

        function calculateCurrent(powerKw, voltageKv, type = 'AC', powerFactor = 0.95) {
            if (type === 'DC') {
                // For UHVDC (Bipole +/- Voltage)
                // Power = 2 * Voltage * Current
                // Current = Power / (2 * Voltage)
                return (powerKw * 1000) / (2 * (voltageKv * 1000));
            }
            // AC 3-Phase
            return (powerKw * 1000) / (Math.sqrt(3) * (voltageKv * 1000) * powerFactor);
        }

        function calculateResistance(r20, tempC, material = 'Al') {
            const alpha = material === 'Cu' ? 0.00393 : 0.00403;
            return r20 * (1 + alpha * (tempC - 20));
        }

        /**
         * IEEE 738 Steady-State Thermal Balance Solver
         */
        function solveTemperature(current, r20_per_km, diameter_mm, params, env, hourIdx, tempCorrection = 0) {
            
            // Get hourly environment data if available
            // Safety check: ensure arrays exist and have data at hourIdx
            let Ta = 25;
            let V_wind = 0.61;
            let Qs_flux = 500;

            if (useLiveData) {
                // Defensive access: Check each array and index explicitly
                if (weatherData.temp && weatherData.temp[hourIdx] !== undefined && weatherData.temp[hourIdx] !== null) {
                    Ta = weatherData.temp[hourIdx];
                }
                if (weatherData.wind && weatherData.wind[hourIdx] !== undefined && weatherData.wind[hourIdx] !== null) {
                    V_wind = weatherData.wind[hourIdx];
                }
                if (weatherData.solar && weatherData.solar[hourIdx] !== undefined && weatherData.solar[hourIdx] !== null) {
                    Qs_flux = weatherData.solar[hourIdx];
                }
            } else {
                Ta = env.ambientTemp;
                V_wind = env.windSpeed;
                Qs_flux = env.solarRadiation;
            }

            // Final Guard against NaN
            if (isNaN(Ta)) Ta = 25;
            if (isNaN(V_wind)) V_wind = 0.61;
            if (isNaN(Qs_flux)) Qs_flux = 0;
            
            // Apply altitude correction to ambient temp
            Ta += tempCorrection;

            let Tc = Ta; // Start guess
            const tolerance = 0.1;
            const maxIter = 100;
            
            const D = diameter_mm / 1000; // meters
            const epsilon = params.emissivity;
            const alpha_solar = params.absorptivity;
            
            // Solar Heat Gain (Q_s)
            const Q_s = alpha_solar * Qs_flux * D; 

            for(let i=0; i<maxIter; i++) {
                const R_km = calculateResistance(r20_per_km, Tc, params.material);
                const R_m = R_km / 1000;
                
                // Joule Heating (Q_j)
                const Q_j = current * current * R_m;
                
                // Radiated Heat Loss (Q_r) - Stefan-Boltzmann
                const sigma = 5.67e-8;
                // Protection against Tc < -273.15 (Absolute Zero error)
                let T_kelvin = Tc + 273.15;
                if (T_kelvin < 0) T_kelvin = 0;
                
                const Q_r = sigma * epsilon * PI * D * (Math.pow(T_kelvin, 4) - Math.pow(Ta + 273.15, 4));
                
                // Convected Heat Loss (Q_c)
                const Tf = (Tc + Ta) / 2; 
                const rho_air = 1.225 * (293 / (Tf + 273.15));
                const mu_air = 1.8e-5;
                const k_air = 0.026;
                
                let Q_c = 0;
                if (V_wind > 0) {
                    const Re = (rho_air * V_wind * D) / mu_air;
                    const Nu = 0.683 * Math.pow(Re, 0.466);
                    const h = (Nu * k_air) / D;
                    Q_c = h * PI * D * (Tc - Ta);
                } else {
                    Q_c = 3.0 * Math.pow(D, 0.75) * Math.pow(Math.abs(Tc - Ta), 1.25); // Math.abs to prevent NaN on negative diff
                }

                const error = (Q_j + Q_s) - (Q_c + Q_r);
                
                // Adaptive step size to prevent divergence
                let step = error * 0.5;
                // Clamp step size to avoid exploding values
                if (step > 50) step = 50;
                if (step < -50) step = -50;
                
                Tc = Tc + step;
                
                if(Math.abs(error) < tolerance) break;
            }
            
            // Final fallback if result is NaN
            if (isNaN(Tc)) return Ta;
            
            return Tc;
        }


        // --- Chart Management ---
        let charts = {};
        // Global access to simulation results for tooltips
        let simResultsGlobal = null;

        function initChart(canvasId, label, color, type) {
            const ctx = document.getElementById(canvasId).getContext('2d');
            return new Chart(ctx, {
                type: 'line',
                data: {
                    labels: SIM_DATA.hours.map(h => `${h}:00`),
                    datasets: [
                        {
                            label: 'Baseline (Without Product)',
                            borderColor: '#94a3b8', // Slate 400
                            borderDash: [5, 5],
                            data: [],
                            tension: 0.4
                        },
                        {
                            label: 'Optimized (With Storix)',
                            borderColor: color,
                            backgroundColor: color + '20',
                            fill: true,
                            data: [],
                            tension: 0.1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    interaction: { mode: 'index', intersect: false },
                    scales: { y: { beginAtZero: false } },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                afterBody: function(context) {
                                    // Only show weather info on one chart to avoid clutter, or all?
                                    // Let's show on Temperature charts.
                                    if (label === 'Temp' && simResultsGlobal) {
                                        const idx = context[0].dataIndex;
                                        
                                        // Retrieve weather data safely
                                        let ta = 25;
                                        let wind = 0.61;
                                        if (useLiveData && weatherData.temp && weatherData.wind) {
                                            ta = weatherData.temp[idx] !== undefined ? weatherData.temp[idx].toFixed(1) : 'N/A';
                                            wind = weatherData.wind[idx] !== undefined ? weatherData.wind[idx].toFixed(1) : 'N/A';
                                        } else {
                                            // Default
                                            ta = 25;
                                            wind = 0.61;
                                        }

                                        return [
                                            `Ambient Temp: ${ta} ¬∞C`,
                                            `Wind Speed: ${wind} m/s`,
                                            `Solar Rad: ${weatherData.solar[idx] || 0} W/m¬≤`
                                        ];
                                    }
                                    return [];
                                }
                            }
                        }
                    }
                }
            });
        }

        // --- Main Simulation Loop ---
        function updateSimulation() {
            // Update Grid Scale from Input
            if(document.getElementById('gridScaleInput')) {
                const scale = parseInt(document.getElementById('gridScaleInput').value);
                if(!isNaN(scale) && scale > 0) {
                    SIM_DATA.scale_transmission = scale;
                }
            }

            // Fallback environment (if not using live data)
            // Note: These inputs are hidden/ignored if live data is active, but kept for logic structure
            // Or we can let user override? For now, if live data is active, we use it.
            const envFallback = {
                ambientTemp: 25,
                windSpeed: 0.61,
                solarRadiation: 500
            };

            // 1. Calculate Load Profiles (Total kW)
            const baseLoadTrans = SIM_DATA.baseline_household_kw.map(kw => kw * SIM_DATA.scale_transmission);
            const optLoadTrans = SIM_DATA.optimized_household_kw.map(kw => kw * SIM_DATA.scale_transmission);

            const baseLoadDist = SIM_DATA.baseline_household_kw.map(kw => kw * SIM_DATA.scale_distribution);
            const optLoadDist = SIM_DATA.optimized_household_kw.map(kw => kw * SIM_DATA.scale_distribution);

            // 2. Physics Simulation Results Arrays
            const results = {
                trans: { baseI: [], optI: [], baseT: [], optT: [] },
                dist: { baseI: [], optI: [], baseT: [], optT: [] }
            };
            simResultsGlobal = results; // Export for tooltips

            const pTrans = SIM_DATA.line_params.transmission;
            const pDist = SIM_DATA.line_params.distribution;
            
            for(let i=0; i<24; i++) {
                // Transmission (AC)
                let I_total_base = calculateCurrent(baseLoadTrans[i], pTrans.voltage_kv, 'AC');
                let I_total_opt = calculateCurrent(optLoadTrans[i], pTrans.voltage_kv, 'AC');
                let I_sub_base = I_total_base / pTrans.num_bundle;
                let I_sub_opt = I_total_opt / pTrans.num_bundle;
                
                results.trans.baseI.push(I_total_base);
                results.trans.optI.push(I_total_opt);
                
                // High Altitude Correction: Subtract 3¬∞C from ambient for transmission lines (approx 500m elevation difference)
                let altCorrection = -3; 
                
                results.trans.baseT.push(solveTemperature(I_sub_base, pTrans.resistance_dc_20_per_km_single, pTrans.diameter_mm, {emissivity: pTrans.emissivity, absorptivity: pTrans.absorptivity, material: 'Al'}, envFallback, i, altCorrection));
                results.trans.optT.push(solveTemperature(I_sub_opt, pTrans.resistance_dc_20_per_km_single, pTrans.diameter_mm, {emissivity: pTrans.emissivity, absorptivity: pTrans.absorptivity, material: 'Al'}, envFallback, i, altCorrection));

                // Distribution (AC)
                let I_base = calculateCurrent(baseLoadDist[i], pDist.voltage_kv, 'AC');
                let I_opt = calculateCurrent(optLoadDist[i], pDist.voltage_kv, 'AC');
                
                results.dist.baseI.push(I_base);
                results.dist.optI.push(I_opt);
                
                results.dist.baseT.push(solveTemperature(I_base, pDist.resistance_dc_20_per_km, pDist.diameter_mm, {emissivity: pDist.emissivity, absorptivity: pDist.absorptivity, material: 'Cu'}, envFallback, i));
                results.dist.optT.push(solveTemperature(I_opt, pDist.resistance_dc_20_per_km, pDist.diameter_mm, {emissivity: pDist.emissivity, absorptivity: pDist.absorptivity, material: 'Cu'}, envFallback, i));
            }

            // 3. Update Charts
            updateChartData(charts.transCurrent, results.trans.baseI, results.trans.optI);
            updateChartData(charts.transTemp, results.trans.baseT, results.trans.optT);
            updateChartData(charts.distCurrent, results.dist.baseI, results.dist.optI);
            updateChartData(charts.distTemp, results.dist.baseT, results.dist.optT);

            // 4. Calculate Metrics (Peak Reduction)
            const maxBaseI = Math.max(...results.trans.baseI);
            const maxOptI = Math.max(...results.trans.optI);
            const currentRed = maxBaseI - maxOptI;
            
            // Peak Temp Reduction: Compare the MAX temperature of both
            // If optimized shifts load to night but increases night temp slightly, 
            // we still care about the REDUCTION of the DANGEROUS peak temp.
            const maxBaseT = Math.max(...results.trans.baseT);
            const maxOptT = Math.max(...results.trans.optT);
            let tempRed = maxBaseT - maxOptT;
            
            // Clamp to 0 if negative (in edge cases where battery charging at night + low wind causes higher night peak than day peak)
            // But realistically, grid peak is much higher. If negative, it means we shifted problem, not solved it.
            // Let's show the real value, but highlight differently if needed.
            // For marketing, we usually want to show reduction of the DAYTIME peak.
            
            // Calculate Savings
            let lossBase = 0;
            let lossOpt = 0;
            
            // New separate tracking for visualization
            let lossTransBaseTotal = 0;
            let lossTransOptTotal = 0;
            let lossDistBaseTotal = 0;
            let lossDistOptTotal = 0;

            // Get lengths from inputs
            const LENGTH_TRANS_KM = parseFloat(document.getElementById('transLenSlider').value) || 1000;
            const LENGTH_DIST_KM = parseFloat(document.getElementById('distLenSlider').value) || 20;

            // Note: Line loss calculation below is simplified for single-phase equivalent resistance?
            // Actually, Total 3-Phase Loss = 3 * I^2 * R_phase.
            // R_phase = R_sub / num_bundle? No.
            // R_DC_20 is usually given per km for the whole bundle or single conductor?
            // "resistance_dc_20_per_km_single": 0.0459. This is for ONE sub-conductor.
            // So Resistance of the Bundle (Phase) = R_single / 8.
            // Current in Bundle (Phase) = I_total.
            // Loss = 3 * I_total^2 * (R_single/8).
            
            // OR: Loss = 3 * 8 * I_sub^2 * R_single.
            // (8 * I_sub)^2 / 8 = 64 * I_sub^2 / 8 = 8 * I_sub^2. Correct.
            // So we can sum losses of all sub-conductors.
            
            for(let i=0; i<24; i++) {
                // --- Transmission Loss ---
                // Calculate R for single sub-conductor at operating temp
                let R_single_base = calculateResistance(pTrans.resistance_dc_20_per_km_single, results.trans.baseT[i], 'Al');
                let R_single_opt = calculateResistance(pTrans.resistance_dc_20_per_km_single, results.trans.optT[i], 'Al');
                
                // Total 3-Phase Loss for Transmission Line
                // Loss = 3 phases * 8 sub-conductors * I_sub^2 * R_single * Length
                let I_sub_base = results.trans.baseI[i] / pTrans.num_bundle;
                let I_sub_opt = results.trans.optI[i] / pTrans.num_bundle;
                
                let loss_trans_base = 3 * pTrans.num_bundle * Math.pow(I_sub_base, 2) * R_single_base * LENGTH_TRANS_KM;
                let loss_trans_opt = 3 * pTrans.num_bundle * Math.pow(I_sub_opt, 2) * R_single_opt * LENGTH_TRANS_KM;
                
                lossTransBaseTotal += loss_trans_base;
                lossTransOptTotal += loss_trans_opt;

                // --- Distribution Loss ---
                // Distribution is simpler: 3-core cable (3 phases), single conductor per phase.
                // Loss = 3 * I^2 * R * Length
                let R_dist_base = calculateResistance(pDist.resistance_dc_20_per_km, results.dist.baseT[i], 'Cu');
                let R_dist_opt = calculateResistance(pDist.resistance_dc_20_per_km, results.dist.optT[i], 'Cu');
                
                let loss_dist_base = 3 * Math.pow(results.dist.baseI[i], 2) * R_dist_base * LENGTH_DIST_KM;
                let loss_dist_opt = 3 * Math.pow(results.dist.optI[i], 2) * R_dist_opt * LENGTH_DIST_KM;

                lossDistBaseTotal += loss_dist_base;
                lossDistOptTotal += loss_dist_opt;
            }

            lossBase = lossTransBaseTotal + lossDistBaseTotal;
            lossOpt = lossTransOptTotal + lossDistOptTotal;
            const savingsKwh = (lossBase - lossOpt) / 1000; // Wh to kWh

            // --- Update Visualization ---
            const savingsTransKwh = (lossTransBaseTotal - lossTransOptTotal) / 1000;
            const savingsDistKwh = (lossDistBaseTotal - lossDistOptTotal) / 1000;
            
            document.getElementById('vizTransSavings').innerText = `${savingsTransKwh.toFixed(0)} kWh`;
            document.getElementById('vizDistSavings').innerText = `${savingsDistKwh.toFixed(0)} kWh`;
            
            document.getElementById('vizTransLen').innerText = `${LENGTH_TRANS_KM} km`;
            document.getElementById('vizDistLen').innerText = `${LENGTH_DIST_KM} km`;
            
            document.getElementById('vizTransVolt').innerText = `${pTrans.voltage_kv} kV`;
            document.getElementById('vizDistVolt').innerText = `${pDist.voltage_kv} kV`;

            // Visualization Weather (Average or current)
            // Just take average for the "General" view
            const avgTemp = (weatherData.temp.reduce((a,b)=>a+b,0)/24).toFixed(1);
            // Transmission line is high altitude (-3C)
            const avgTransTemp = (parseFloat(avgTemp) - 3).toFixed(1);
            
            document.getElementById('vizTransWeather').innerText = `Avg Amb: ${avgTransTemp}¬∞C`;
            document.getElementById('vizDistWeather').innerText = `Avg Amb: ${avgTemp}¬∞C`;
            
            document.getElementById('vizHouseCount').innerText = `${SIM_DATA.scale_transmission.toLocaleString()} Users`;

            // Total Energy Calculation
            const totalBaseKwh = SIM_DATA.baseline_household_kw.reduce((a, b) => a + b, 0);
            const totalOptKwh = SIM_DATA.optimized_household_kw.reduce((a, b) => a + b, 0);
            const diffKwh = totalOptKwh - totalBaseKwh;
            const pctDiff = (diffKwh / totalBaseKwh) * 100;

            document.getElementById('metricCurrentRed').innerText = `${currentRed.toFixed(1)} A`;
            document.getElementById('metricTempRed').innerText = `${tempRed.toFixed(1)} ¬∞C`;
            document.getElementById('metricSavings').innerText = `${savingsKwh.toFixed(0)} kWh`;
            
            document.getElementById('metricTotalEnergy').innerText = `+${pctDiff.toFixed(1)}%`;
            document.getElementById('metricTotalEnergy').className = "metric-value text-red-600"; // Red because it increased
            document.getElementById('valBaseEnergy').innerText = totalBaseKwh.toFixed(1);
            document.getElementById('valOptEnergy').innerText = totalOptKwh.toFixed(1);
            
            // Update Household Count Display
            if(document.getElementById('householdCountDisplay')) {
                document.getElementById('householdCountDisplay').innerText = SIM_DATA.scale_transmission.toLocaleString();
            }
        }

        function updateChartData(chart, dataBase, dataOpt) {
            chart.data.datasets[0].data = dataBase;
            chart.data.datasets[1].data = dataOpt;
            chart.update();
        }

        // Initialize
        window.onload = function() {
            charts.transCurrent = initChart('chartTransCurrent', 'Current', '#3b82f6');
            charts.transTemp = initChart('chartTransTemp', 'Temp', '#ef4444');
            charts.distCurrent = initChart('chartDistCurrent', 'Current', '#3b82f6');
            charts.distTemp = initChart('chartDistTemp', 'Temp', '#ef4444');
            
            updateSimulation();
        };

    </script>
</body>
</html>
